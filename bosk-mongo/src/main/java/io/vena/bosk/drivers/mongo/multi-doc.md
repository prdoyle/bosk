
## Design principles

### Manifest is the system of record for layout

A `MongoDriver` will accept a configuration describing the desired database layout.
However, if the database already exists, this is ignored, and the layout from the `manifest` document is used instead.
(In this way, the layout acts like the `initialState`.)

Any change to the `manifest` document probably triggers the bosk to be reloaded
the same way as for `initialState`.

### Scattering and gathering are done by mutating Bson objects

A single bosk update can correspond to multiple database writes,
and conversely, multiple change events can correspond to a single bosk update.
We refer to these as "scattering" and "gathering", respectively.

Scattering is done in these steps:
1. Serialize the bosk state into Bson as usual
2. Mutate the Bson to separate it into multiple Bsons based on the database layout
3. Write the objects in bottom-up order

Gathering is done in these steps:
1. Receive all the change events and buffer them, bottom-up, ending with the top Bson object
2. Mutate the top object to include all the other objects 
3. Deserialize the Bson into bosk state as usual

### Limitations

There are some decisions we can make initially that will simplify the implementation.
We might find ways to overcome these limitations in the future.

#### Deleted nodes can be left behind

Suppose a Catalog is configured to use a separate collection, and it contains objects `A` and `B`.
Then an update arrives to replace that with `A` and `C`.
The driver is allowed to leave the `B` document intact.

Dangling documents can be cleared via `refurbish()` if desired.

An explicit `submitDeletion` shouldn't leave the document behind.

#### Complexity limits

Any or all of these limits might apply:
- Just one separate collection allowed
- The path of a separate collection may contain a limited number of parameters (perhaps none, or just one) 

## Database contents

### Collection `main`

#### Document `manifest`

Fields:
- `formatVersion`: a three-segment version number `x.y.z` identifying the layout conventions
- `separateCollections`: map of small integer _ordinals_ to references to Catalogs or SideTables that have their own collections
    - Can be paramaterized refs

#### Document `root`

Fields:
- `path`: always contains the string `/`
- `state`: the bosk state
  - Any separate collections (Catalogs or SideTables) map IDs to the value `true` (rather than containing the actual tree node)
- `echo`: used to implement `flush`

### Collection `path:{ordinal}:{ids}`

- `ordinal` is specified by the `separateCollections` field in the `manifest` document
- `ids` is a comma-separated list of percent-encoded ids for any parameters in the reference 

Both colons are always present, even if `ids` is the empty list.
Splitting on the colon character always results in three strings.

#### Document `node:{id}`

- `id` is the percent-encoded `Entity.id()` of the node

Fields:
- `path`: The node's bosk path string, as generated by `Path.urlEncoded()`
- `state`: The node's serialized state 
