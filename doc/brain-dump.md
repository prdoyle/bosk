### Reads

Users read a node from the state tree by calling `Reference.valueIfExists()` on a `Reference` that points to the desired node.
The value returned will depend on the `ReadContext` that is active on the calling thread:
for the duration of a `ReadContext`, the same value will always be returned,
taken from a snapshot of the bosk state at the time the context was created.
While a `ReadContext` is active on a thread, opening a new `ReadContext` will produce one with the same state snapshot,
and will therefore have no effect.

`Reference.valueIfExists()` works by walking the state tree from the root, step by step,
calling the getter methods indicated by each `Path` segment in turn.
For example, a reference whose path is `/a/b/c` would call `root.a().b().c()`
if all the nodes are ordinary nodes.
Some special nodes implement a path step differently:

- `Catalog` and `SideTable` (implementations of `AdressableByIdentifier`) use the `get` method,
   passing in the identifier from the corresponding location in the path.
   For example, if `/a` points to a `Catalog`, `/a/b` would call `root.a().get(reference.idAt(1))`
- `Optional` is stepped over transparently;
   that is, an `Optional<T>` that is present is handled exactly like a `T`.
   For example, if `/a` points to an `Optional`, `/a/b` would call `root.a().b().orElse(null)`. 
- `Phantom` is treated like an `Optional` that is always absent. 
- `Listing` behaves as though it returns `ListingEntry.LISTING_ENTRY` if the item is present in the `Listing`.
  For example, if `/a` points to a `Listing`, `/a/b` would call `root.a().contains(reference.idAt(1))? LISTING_ENTRY : null`. 

To implement this efficiently, the `PathCompiler` component translates path strings into bytecode sequences.
The `PathCompiler` produces objects of type `Dereferencer` that perform the performance-critical portions of the read (and update) operations.
The implementation of `Reference.valueIfExists()` lazily compiles a `Dereferencer` to which it delegates the call.
The `Dereferencer` objects internally throw `NonexistentEntityException` to short-circuit the walk,
stopping as soon as the reference is found to be nonexistent.

### Updates

Changes to the state tree are submitted to the Bosk object via the `BoskDriver` interface:
a stackable, modular interface that permits customization of the update behaviour.
The interface provides replacement and deletion operations, plus conditional versions of each.
It also provides a `flush()` operation that blocks until all prior updates have been applied to the local state;
after a call to `flush()`, a newly created `ReadContext` will reflect all prior updates.

The basic driver, having no special functionality, is `LocalDriver`, which applies the changes directly to the in-memory state tree.
It does this by performing a "grafting" operation, combining new tree nodes with existing nodes to form a new tree.
As with read operations, the `Dereferencer` object generated by the `PathCompiler` component is used for efficiency:
the performance-critical parts of the graft operation are executed by generated bytecode sequences.

#### `MongoDriver`

The `MongoDriver` component is a stackable layer that adds durability and replication for updates,
resting atop a downstream driver that is responsible for applying Bosk changes in memory as described above.
The `MongoDriver` layer splits each update into two distinct operations:

1. Each Bosk update supplied to `MongoDriver` is executed as a database update operation.
2. Each update received from the MongoDB change stream is passed along to the downstream driver to be applied to the in-memory state tree.

#### Hooks

Every update has the potential to trigger _hooks_, which are callback functions registered by the user to respond to changes to a given part of the state tree.

A hook is guaranteed to run under three circumstances:
1. An update to the exact node on which the hook was registered
2. An update to a child or descendant of the registered node
3. An update to a parent or ancestor of the registered node

The bosk library also reserves the right to make occasional hook calls even if the tree did not change.
For efficiency, Bosk avoid calling hooks unnecessarily on a best-effort basis.

Hooks can be registered on parameterized references, in which case they apply to every node whose path they match,
whether or not the node existed at the time the hook was registered.

Because hooks may themselves perform bosk updates, some discipline is required in order to have hooks run in the same predictable order every time.
Hooks are executed breadth-first, in the sense that if some update triggers hooks,
all those hooks will run before any hooks they themselves trigger.

The triggering logic is algorithmically sophisticated in order to provide triggering that is efficient for local operation
while retaining efficient, predictable, repeatable behaviour when operating an asynchronous, distributed fashion.
The algorithm would be a straightforward BFS algorithm if not for the fact that Bosk is not in control of the "outermost loop" of the algorithm;
the result is a kind of "reactive BFS" that gets called from user code.
The algorithm is described in more detail in the code comments.

Every hook is executed within a `ReadContext` that contains a snapshot of the state tree immediately after the update that triggered the hook.
Even if the state tree continues to evolve while hooks are pending, those hooks will still observe the right state snapshot.

### Type validation

The bosk state tree does not support arbitrary Java objects; it is restricted to immutable objects having certain properties.

#### Built-in types

Some Java types are permitted: String, enums, boxed primitives. (Arrays are not allowed because they are mutable.)

Bosk library types are permitted: `Identifier`, `Reference`, `Catalog`, `Listing`, `SideTable`, `Phantom`, `ListValue`, `MapValue`.

#### User-supplied types

First, in order to ensure the nodes are immutable, the following structural rules are enforced:
- The type must be public
- The type must implement `StateTreeNode` (directly or indirectly) 
- Any fields must be final
- There must be exactly one constructor

Having passed these rules, the rest of the analysis is driven by the constructor.
The number, names, types, and order of child nodes are inferred from the constructor's arguments.
(The code must be compiled with the javac `-parameters` option so that parameter name information is present in the bytecode.)

The validity rules are compatible with Java 14 _records_; users are encouraged (but not required) to use records.
For each child node, there must be a corresponding getter method with no arguments,
whose name and return type match those of the corresponding constructor parameter.
The getter methods are used for read operations, and the constructor is used for grafting.

There are a few exceptional cases in which constructor parameters do not need corresponding getters;
these are called _implicit parameters_ and are handled specially by Bosk, so getters are not required:

- The `@Self` reference points to the node itself within the state tree
- An `@Enclosing` reference points to some ancestor node within the state tree

Bosk can supply these without any help from the user-supplied code.
